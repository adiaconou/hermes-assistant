#!/usr/bin/env node
// Agent catalog generator â€” reads src/registry/agents.ts and
// src/domains/*/capability.ts to produce docs/generated/agent-catalog.md.

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, '..');
const DOMAINS_DIR = path.join(ROOT, 'src', 'domains');
const REGISTRY_PATH = path.join(ROOT, 'src', 'registry', 'agents.ts');
const OUTPUT_PATH = path.join(ROOT, 'docs', 'generated', 'agent-catalog.md');

// ---------- Parse registry agents ----------

const registryAgents = [];

if (fs.existsSync(REGISTRY_PATH)) {
  const registrySrc = fs.readFileSync(REGISTRY_PATH, 'utf-8');
  const importRe = /import\s+\{[^}]*capability\s+as\s+(\w+).*?\}\s+from\s+['"]([^'"]+)['"]/g;
  let m;
  while ((m = importRe.exec(registrySrc)) !== null) {
    const importPath = m[2];
    const agentsMatch = importPath.match(/agents\/(\w+)\//);
    const domainsMatch = importPath.match(/domains\/([^/]+)\//);
    const name = agentsMatch?.[1] || domainsMatch?.[1] || 'unknown';
    registryAgents.push(name);
  }
}

// ---------- Parse domain capabilities ----------

const domains = [];

if (fs.existsSync(DOMAINS_DIR)) {
  for (const entry of fs.readdirSync(DOMAINS_DIR, { withFileTypes: true })) {
    if (!entry.isDirectory()) continue;
    const domainName = entry.name;
    const capPath = path.join(DOMAINS_DIR, domainName, 'capability.ts');

    if (!fs.existsSync(capPath)) continue;

    const capSrc = fs.readFileSync(capPath, 'utf-8');
    const exposureMatch = capSrc.match(/exposure:\s*['"]([\w-]+)['"]/);
    const agentIdMatch = capSrc.match(/agentId:\s*['"]([^'"]+)['"]/);
    const toolsMatch = capSrc.match(/tools:\s*\[([^\]]*)\]/);

    const tools = toolsMatch
      ? toolsMatch[1].match(/'([^']+)'/g)?.map(t => t.replace(/'/g, '')) || []
      : [];

    domains.push({
      domain: domainName,
      exposure: exposureMatch?.[1] || 'unknown',
      agentId: agentIdMatch?.[1] || null,
      tools,
    });
  }
}

// ---------- Generate markdown ----------

const lines = [
  '# Agent Catalog',
  '',
  '> Auto-generated by `npm run docs:agents`. Do not edit manually.',
  '',
  `Generated: ${new Date().toISOString().split('T')[0]}`,
  '',
];

// Active agents (from registry)
lines.push('## Active Agents', '');
lines.push('Agents registered in `src/registry/agents.ts`:', '');
lines.push('| Agent | Source |');
lines.push('|-------|--------|');

for (const name of registryAgents) {
  const domain = domains.find(d => d.domain === name);
  const source = domain
    ? `src/domains/${name}/runtime/agent.ts`
    : `src/agents/${name}/index.ts`;
  lines.push(`| ${name} | \`${source}\` |`);
}
lines.push('');

// Domain capabilities
if (domains.length > 0) {
  lines.push('## Domain Capabilities', '');
  lines.push('| Domain | Exposure | Agent ID | Tools |');
  lines.push('|--------|----------|----------|-------|');

  for (const d of domains) {
    const toolList = d.tools.length > 0 ? d.tools.join(', ') : '\u2014';
    lines.push(`| ${d.domain} | ${d.exposure} | ${d.agentId || '\u2014'} | ${toolList} |`);
  }
  lines.push('');
}

// Ensure output directory exists
const outputDir = path.dirname(OUTPUT_PATH);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

fs.writeFileSync(OUTPUT_PATH, lines.join('\n') + '\n');
console.log(`Agent catalog written to ${path.relative(ROOT, OUTPUT_PATH)}`);
